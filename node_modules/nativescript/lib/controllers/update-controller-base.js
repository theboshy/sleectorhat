"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const semver = require("semver");
class UpdateControllerBase {
    constructor($fs, $platformCommandHelper, $platformsDataService, $packageInstallationManager, $packageManager, $pacoteService) {
        this.$fs = $fs;
        this.$platformCommandHelper = $platformCommandHelper;
        this.$platformsDataService = $platformsDataService;
        this.$packageInstallationManager = $packageInstallationManager;
        this.$packageManager = $packageManager;
        this.$pacoteService = $pacoteService;
        this.getPackageManifest = _.memoize(this._getPackageManifest, (...args) => {
            return args.join("@");
        });
    }
    restoreBackup(folders, backupDir, projectDir) {
        for (const folder of folders) {
            this.$fs.deleteDirectory(path.join(projectDir, folder));
            const folderToCopy = path.join(backupDir, folder);
            if (this.$fs.exists(folderToCopy)) {
                this.$fs.copyFile(folderToCopy, projectDir);
            }
        }
    }
    backup(folders, backupDir, projectDir) {
        this.$fs.deleteDirectory(backupDir);
        this.$fs.createDirectory(backupDir);
        for (const folder of folders) {
            const folderToCopy = path.join(projectDir, folder);
            if (this.$fs.exists(folderToCopy)) {
                this.$fs.copyFile(folderToCopy, backupDir);
            }
        }
    }
    hasDependency(dependency, projectData) {
        const devDependencies = projectData.devDependencies;
        const dependencies = projectData.dependencies;
        return (dependencies && dependencies[dependency.packageName]) || (devDependencies && devDependencies[dependency.packageName]);
    }
    hasRuntimeDependency({ platform, projectData }) {
        const lowercasePlatform = platform.toLowerCase();
        const currentPlatformVersion = this.$platformCommandHelper.getCurrentPlatformVersion(lowercasePlatform, projectData);
        return !!currentPlatformVersion;
    }
    getMaxRuntimeVersion({ platform, projectData }) {
        return __awaiter(this, void 0, void 0, function* () {
            const lowercasePlatform = platform.toLowerCase();
            const currentPlatformVersion = this.$platformCommandHelper.getCurrentPlatformVersion(lowercasePlatform, projectData);
            const platformData = this.$platformsDataService.getPlatformData(lowercasePlatform, projectData);
            if (currentPlatformVersion) {
                return (yield this.$packageInstallationManager.getMaxSatisfyingVersionSafe(platformData.frameworkPackageName, currentPlatformVersion)) || currentPlatformVersion;
            }
        });
    }
    _getPackageManifest(templateName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageVersion = semver.valid(version) || (yield this.$packageManager.getTagVersion(templateName, version));
            if (packageVersion && semver.valid(packageVersion)) {
                return yield this.$pacoteService.manifest(`${templateName}@${packageVersion}`, { fullMetadata: true });
            }
            else {
                throw new Error(`Failed to get information for package: ${templateName}@${version}`);
            }
        });
    }
}
exports.UpdateControllerBase = UpdateControllerBase;
