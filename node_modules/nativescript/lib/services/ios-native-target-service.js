"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
class IOSNativeTargetService {
    constructor($fs, $pbxprojDomXcode) {
        this.$fs = $fs;
        this.$pbxprojDomXcode = $pbxprojDomXcode;
    }
    addTargetToProject(targetRootPath, targetFolder, targetType, project, platformData, parentTarget) {
        const targetPath = path.join(targetRootPath, targetFolder);
        const targetRelativePath = path.relative(platformData.projectRoot, targetPath);
        const files = this.$fs.readDirectory(targetPath)
            .filter(filePath => !filePath.startsWith("."))
            .map(filePath => path.join(targetPath, filePath));
        const target = project.addTarget(targetFolder, targetType, targetRelativePath, parentTarget);
        project.addBuildPhase([], 'PBXSourcesBuildPhase', 'Sources', target.uuid);
        project.addBuildPhase([], 'PBXResourcesBuildPhase', 'Resources', target.uuid);
        project.addBuildPhase([], 'PBXFrameworksBuildPhase', 'Frameworks', target.uuid);
        project.addPbxGroup(files, targetFolder, targetPath, null, { isMain: true, target: target.uuid, filesRelativeToProject: true });
        project.addToHeaderSearchPaths(targetPath, target.pbxNativeTarget.productName);
        return target;
    }
    prepareSigning(targetUuids, projectData, projectPath) {
        const xcode = this.$pbxprojDomXcode.Xcode.open(projectPath);
        const signing = xcode.getSigning(projectData.projectName);
        if (signing !== undefined) {
            _.forEach(targetUuids, targetUuid => {
                if (signing.style === "Automatic") {
                    xcode.setAutomaticSigningStyleByTargetKey(targetUuid, signing.team);
                }
                else {
                    for (const config in signing.configurations) {
                        const signingConfiguration = signing.configurations[config];
                        xcode.setManualSigningStyleByTargetKey(targetUuid, signingConfiguration);
                        break;
                    }
                }
            });
        }
        xcode.save();
    }
    getTargetDirectories(folderPath) {
        return this.$fs.readDirectory(folderPath)
            .filter(fileName => {
            const filePath = path.join(folderPath, fileName);
            const stats = this.$fs.getFsStats(filePath);
            return stats.isDirectory() && !fileName.startsWith(".");
        });
    }
    setXcodeTargetBuildConfigurationProperties(properties, targetName, project) {
        properties.forEach(property => {
            const buildNames = property.buildNames || ["Debug", "Release"];
            buildNames.forEach((buildName) => {
                project.addBuildProperty(property.name, property.value, buildName, targetName);
            });
        });
    }
    setConfigurationsFromJsonFile(jsonPath, targetUuid, targetName, project) {
        if (this.$fs.exists(jsonPath)) {
            const configurationJson = this.$fs.readJson(jsonPath) || {};
            _.forEach(configurationJson.frameworks, framework => {
                project.addFramework(framework, { target: targetUuid });
            });
            if (configurationJson.assetcatalogCompilerAppiconName) {
                project.addToBuildSettings("ASSETCATALOG_COMPILER_APPICON_NAME", configurationJson.assetcatalogCompilerAppiconName, targetUuid);
            }
            if (configurationJson.targetBuildConfigurationProperties) {
                const properties = [];
                _.forEach(configurationJson.targetBuildConfigurationProperties, (value, name) => properties.push({ value, name }));
                this.setXcodeTargetBuildConfigurationProperties(properties, targetName, project);
            }
        }
    }
}
exports.IOSNativeTargetService = IOSNativeTargetService;
$injector.register("iOSNativeTargetService", IOSNativeTargetService);
