"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const constants_1 = require("../constants");
class IOSExtensionsService {
    constructor($fs, $pbxprojDomXcode, $xcode, $iOSNativeTargetService) {
        this.$fs = $fs;
        this.$pbxprojDomXcode = $pbxprojDomXcode;
        this.$xcode = $xcode;
        this.$iOSNativeTargetService = $iOSNativeTargetService;
    }
    addExtensionsFromPath({ extensionsFolderPath, projectData, platformData, pbxProjPath }) {
        return __awaiter(this, void 0, void 0, function* () {
            const targetUuids = [];
            let addedExtensions = false;
            if (!this.$fs.exists(extensionsFolderPath)) {
                return false;
            }
            const project = new this.$xcode.project(pbxProjPath);
            project.parseSync();
            this.$iOSNativeTargetService.getTargetDirectories(extensionsFolderPath)
                .forEach(extensionFolder => {
                const target = this.$iOSNativeTargetService.addTargetToProject(extensionsFolderPath, extensionFolder, constants_1.IOSNativeTargetTypes.appExtension, project, platformData);
                this.configureTarget(extensionFolder, path.join(extensionsFolderPath, extensionFolder), target, project, projectData);
                targetUuids.push(target.uuid);
                addedExtensions = true;
            });
            this.$fs.writeFile(pbxProjPath, project.writeSync({ omitEmptyValues: true }));
            this.$iOSNativeTargetService.prepareSigning(targetUuids, projectData, pbxProjPath);
            return addedExtensions;
        });
    }
    configureTarget(extensionName, extensionPath, target, project, projectData) {
        const extJsonPath = path.join(extensionPath, "extension.json");
        this.$iOSNativeTargetService.setXcodeTargetBuildConfigurationProperties([{ name: "PRODUCT_BUNDLE_IDENTIFIER", value: `${projectData.projectIdentifiers.ios}.${extensionName}` }], extensionName, project);
        this.$iOSNativeTargetService.setConfigurationsFromJsonFile(extJsonPath, target.uuid, extensionName, project);
    }
    removeExtensions({ pbxProjPath }) {
        const project = new this.$xcode.project(pbxProjPath);
        project.parseSync();
        project.removeTargetsByProductType(constants_1.IOSNativeTargetProductTypes.appExtension);
        this.$fs.writeFile(pbxProjPath, project.writeSync({ omitEmptyValues: true }));
    }
}
exports.IOSExtensionsService = IOSExtensionsService;
$injector.register("iOSExtensionsService", IOSExtensionsService);
