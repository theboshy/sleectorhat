"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_executor_1 = require("@nativescript/schematics-executor");
class GenerateCommand {
    constructor($logger, $options, $errors) {
        this.$logger = $logger;
        this.$options = $options;
        this.$errors = $errors;
        this.allowedParameters = [];
    }
    execute(_rawArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield schematics_executor_1.run(this.executionOptions);
            }
            catch (error) {
                this.$errors.fail(error.message);
            }
        });
    }
    canExecute(rawArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setExecutionOptions(rawArgs);
            this.validateExecutionOptions();
            return true;
        });
    }
    validateExecutionOptions() {
        if (!this.executionOptions.schematic) {
            this.$errors.failWithHelp(`The generate command requires a schematic name to be specified.`);
        }
    }
    setExecutionOptions(rawArgs) {
        const options = this.parseRawArgs(rawArgs);
        this.executionOptions = Object.assign({}, options, { logger: this.$logger, directory: process.cwd() });
    }
    parseRawArgs(rawArgs) {
        const collection = this.$options.collection;
        const schematic = rawArgs.shift();
        const { options, args } = parseSchematicSettings(rawArgs);
        return {
            collection,
            schematic,
            schematicOptions: options,
            schematicArgs: args,
        };
    }
}
exports.GenerateCommand = GenerateCommand;
function parseSchematicSettings(rawArgs) {
    const [optionStrings, args] = partition(rawArgs, item => item.includes('='));
    const options = optionStrings
        .map(o => o.split("="))
        .map(([key, ...value]) => [key, value.join("=")])
        .reduce((obj, [key, value]) => {
        return Object.assign({}, obj, { [key]: value });
    }, {});
    return { options, args };
}
function partition(array, predicate) {
    return array.reduce(([pass, fail], item) => {
        return predicate(item) ?
            [[...pass, item], fail] :
            [pass, [...fail, item]];
    }, [[], []]);
}
$injector.registerCommand("generate", GenerateCommand);
