"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const command_base_1 = require("./command-base");
const helpers_1 = require("../common/helpers");
class BuildCommandBase extends command_base_1.ValidatePlatformCommandBase {
    constructor($options, $errors, $projectData, $platformsDataService, $devicePlatformsConstants, $buildController, $platformValidationService, $buildDataService, $logger) {
        super($options, $platformsDataService, $platformValidationService, $projectData);
        this.$errors = $errors;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$buildController = $buildController;
        this.$buildDataService = $buildDataService;
        this.$logger = $logger;
        this.dashedOptions = {
            watch: { type: "boolean", default: false, hasSensitiveValue: false },
            hmr: { type: "boolean", default: false, hasSensitiveValue: false },
        };
        this.$projectData.initializeProjectData();
    }
    executeCore(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const platform = args[0].toLowerCase();
            const buildData = this.$buildDataService.getBuildData(this.$projectData.projectDir, platform, this.$options);
            const outputPath = yield this.$buildController.prepareAndBuild(buildData);
            return outputPath;
        });
    }
    validatePlatform(platform) {
        if (!this.$platformValidationService.isPlatformSupportedForOS(platform, this.$projectData)) {
            this.$errors.fail(`Applications for platform ${platform} can not be built on this OS`);
        }
    }
    validateArgs(args, platform) {
        return __awaiter(this, void 0, void 0, function* () {
            if (args.length !== 0) {
                this.$errors.failWithHelp(`The arguments '${args.join(" ")}' are not valid for the current command.`);
            }
            const result = yield this.$platformValidationService.validateOptions(this.$options.provision, this.$options.teamId, this.$projectData, platform);
            return result;
        });
    }
}
exports.BuildCommandBase = BuildCommandBase;
class BuildIosCommand extends BuildCommandBase {
    constructor($options, $errors, $projectData, $platformsDataService, $devicePlatformsConstants, $buildController, $platformValidationService, $logger, $buildDataService, $migrateController) {
        super($options, $errors, $projectData, $platformsDataService, $devicePlatformsConstants, $buildController, $platformValidationService, $buildDataService, $logger);
        this.$options = $options;
        this.$migrateController = $migrateController;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.executeCore([this.$devicePlatformsConstants.iOS.toLowerCase()]);
        });
    }
    canExecute(args) {
        const _super = Object.create(null, {
            validatePlatform: { get: () => super.validatePlatform },
            canExecuteCommandBase: { get: () => super.canExecuteCommandBase },
            validateArgs: { get: () => super.validateArgs }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const platform = this.$devicePlatformsConstants.iOS;
            if (!this.$options.force) {
                yield this.$migrateController.validate({ projectDir: this.$projectData.projectDir, platforms: [platform] });
            }
            _super.validatePlatform.call(this, platform);
            let canExecute = yield _super.canExecuteCommandBase.call(this, platform, { notConfiguredEnvOptions: { hideSyncToPreviewAppOption: true } });
            if (canExecute) {
                canExecute = yield _super.validateArgs.call(this, args, platform);
            }
            return canExecute;
        });
    }
}
exports.BuildIosCommand = BuildIosCommand;
$injector.registerCommand("build|ios", BuildIosCommand);
class BuildAndroidCommand extends BuildCommandBase {
    constructor($options, $errors, $projectData, platformsDataService, $devicePlatformsConstants, $buildController, $platformValidationService, $androidBundleValidatorHelper, $buildDataService, $logger, $migrateController, $markingModeService) {
        super($options, $errors, $projectData, platformsDataService, $devicePlatformsConstants, $buildController, $platformValidationService, $buildDataService, $logger);
        this.$options = $options;
        this.$errors = $errors;
        this.$androidBundleValidatorHelper = $androidBundleValidatorHelper;
        this.$logger = $logger;
        this.$migrateController = $migrateController;
        this.$markingModeService = $markingModeService;
        this.allowedParameters = [];
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$markingModeService.handleMarkingModeFullDeprecation({ projectDir: this.$projectData.projectDir, skipWarnings: true });
            yield this.executeCore([this.$devicePlatformsConstants.Android.toLowerCase()]);
            if (this.$options.aab) {
                this.$logger.info(constants_1.AndroidAppBundleMessages.ANDROID_APP_BUNDLE_DOCS_MESSAGE);
                if (this.$options.release) {
                    this.$logger.info(constants_1.AndroidAppBundleMessages.ANDROID_APP_BUNDLE_PUBLISH_DOCS_MESSAGE);
                }
            }
        });
    }
    canExecute(args) {
        const _super = Object.create(null, {
            canExecuteCommandBase: { get: () => super.canExecuteCommandBase },
            validateArgs: { get: () => super.validateArgs }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const platform = this.$devicePlatformsConstants.Android;
            if (!this.$options.force) {
                yield this.$migrateController.validate({ projectDir: this.$projectData.projectDir, platforms: [platform] });
            }
            this.$androidBundleValidatorHelper.validateRuntimeVersion(this.$projectData);
            let canExecute = yield _super.canExecuteCommandBase.call(this, platform, { notConfiguredEnvOptions: { hideSyncToPreviewAppOption: true } });
            if (canExecute) {
                if (this.$options.release && !helpers_1.hasValidAndroidSigning(this.$options)) {
                    this.$errors.failWithHelp(constants_1.ANDROID_RELEASE_BUILD_ERROR_MESSAGE);
                }
                canExecute = yield _super.validateArgs.call(this, args, platform);
            }
            return canExecute;
        });
    }
}
exports.BuildAndroidCommand = BuildAndroidCommand;
$injector.registerCommand("build|android", BuildAndroidCommand);
