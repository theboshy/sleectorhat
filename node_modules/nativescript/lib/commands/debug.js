"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../common/decorators");
const command_base_1 = require("./command-base");
const helpers_1 = require("../common/helpers");
const constants_1 = require("../constants");
class DebugPlatformCommand extends command_base_1.ValidatePlatformCommandBase {
    constructor(platform, $devicesService, $platformValidationService, $projectData, $options, $platformsDataService, $cleanupService, $logger, $errors, $debugDataService, $debugController, $liveSyncCommandHelper, $migrateController) {
        super($options, $platformsDataService, $platformValidationService, $projectData);
        this.platform = platform;
        this.$devicesService = $devicesService;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$debugDataService = $debugDataService;
        this.$debugController = $debugController;
        this.$liveSyncCommandHelper = $liveSyncCommandHelper;
        this.$migrateController = $migrateController;
        this.allowedParameters = [];
        $cleanupService.setShouldDispose(false);
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$devicesService.initialize({
                platform: this.platform,
                deviceId: this.$options.device,
                emulator: this.$options.emulator,
                skipDeviceDetectionInterval: true
            });
            const selectedDeviceForDebug = yield this.$devicesService.pickSingleDevice({
                onlyEmulators: this.$options.emulator,
                onlyDevices: this.$options.forDevice,
                deviceId: this.$options.device
            });
            if (this.$options.start) {
                const debugOptions = _.cloneDeep(this.$options.argv);
                const debugData = this.$debugDataService.getDebugData(selectedDeviceForDebug.deviceInfo.identifier, this.$projectData, debugOptions);
                yield this.$debugController.printDebugInformation(yield this.$debugController.startDebug(debugData));
                return;
            }
            yield this.$liveSyncCommandHelper.executeLiveSyncOperation([selectedDeviceForDebug], this.platform, {
                deviceDebugMap: {
                    [selectedDeviceForDebug.deviceInfo.identifier]: true
                },
                buildPlatform: undefined,
                skipNativePrepare: false
            });
        });
    }
    canExecute(args) {
        const _super = Object.create(null, {
            canExecuteCommandBase: { get: () => super.canExecuteCommandBase }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.$options.force) {
                yield this.$migrateController.validate({ projectDir: this.$projectData.projectDir, platforms: [this.platform] });
            }
            if (!this.$platformValidationService.isPlatformSupportedForOS(this.platform, this.$projectData)) {
                this.$errors.fail(`Applications for platform ${this.platform} can not be built on this OS`);
            }
            if (this.$options.release) {
                this.$errors.failWithHelp("--release flag is not applicable to this command.");
            }
            const result = yield _super.canExecuteCommandBase.call(this, this.platform, { validateOptions: true, notConfiguredEnvOptions: { hideCloudBuildOption: true, hideSyncToPreviewAppOption: true } });
            return result;
        });
    }
}
exports.DebugPlatformCommand = DebugPlatformCommand;
class DebugIOSCommand {
    constructor($errors, $devicePlatformsConstants, $platformValidationService, $options, $injector, $sysInfo, $projectData, $iosDeviceOperations, $iOSSimulatorLogProvider) {
        this.$errors = $errors;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$platformValidationService = $platformValidationService;
        this.$options = $options;
        this.$injector = $injector;
        this.$sysInfo = $sysInfo;
        this.$projectData = $projectData;
        this.allowedParameters = [];
        this.platform = this.$devicePlatformsConstants.iOS;
        this.$projectData.initializeProjectData();
        $iosDeviceOperations.setShouldDispose(false);
        $iOSSimulatorLogProvider.setShouldDispose(false);
    }
    get debugPlatformCommand() {
        return this.$injector.resolve(DebugPlatformCommand, { platform: this.platform });
    }
    execute(args) {
        return this.debugPlatformCommand.execute(args);
    }
    canExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.$platformValidationService.isPlatformSupportedForOS(this.$devicePlatformsConstants.iOS, this.$projectData)) {
                this.$errors.fail(`Applications for platform ${this.$devicePlatformsConstants.iOS} can not be built on this OS`);
            }
            const isValidTimeoutOption = this.isValidTimeoutOption();
            if (!isValidTimeoutOption) {
                this.$errors.fail(`Timeout option specifies the seconds NativeScript CLI will wait to find the inspector socket port from device's logs. Must be a number.`);
            }
            if (this.$options.inspector) {
                const macOSWarning = yield this.$sysInfo.getMacOSWarningMessage();
                if (macOSWarning && macOSWarning.severity === "high") {
                    this.$errors.fail(`You cannot use NativeScript Inspector on this OS. To use it, please update your OS.`);
                }
            }
            const result = yield this.debugPlatformCommand.canExecute(args);
            return result;
        });
    }
    isValidTimeoutOption() {
        if (!this.$options.timeout) {
            return true;
        }
        const timeout = parseInt(this.$options.timeout, 10);
        if (timeout === 0) {
            return true;
        }
        if (!timeout) {
            return false;
        }
        return true;
    }
}
__decorate([
    decorators_1.cache()
], DebugIOSCommand.prototype, "debugPlatformCommand", null);
exports.DebugIOSCommand = DebugIOSCommand;
$injector.registerCommand("debug|ios", DebugIOSCommand);
class DebugAndroidCommand {
    constructor($errors, $devicePlatformsConstants, $injector, $projectData, $markingModeService, $options) {
        this.$errors = $errors;
        this.$devicePlatformsConstants = $devicePlatformsConstants;
        this.$injector = $injector;
        this.$projectData = $projectData;
        this.$markingModeService = $markingModeService;
        this.$options = $options;
        this.allowedParameters = [];
        this.platform = this.$devicePlatformsConstants.Android;
        this.$projectData.initializeProjectData();
    }
    get debugPlatformCommand() {
        return this.$injector.resolve(DebugPlatformCommand, { platform: this.platform });
    }
    execute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$markingModeService.handleMarkingModeFullDeprecation({ projectDir: this.$projectData.projectDir, skipWarnings: true });
            return this.debugPlatformCommand.execute(args);
        });
    }
    canExecute(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const canExecuteBase = yield this.debugPlatformCommand.canExecute(args);
            if (canExecuteBase) {
                if (this.$options.aab && !helpers_1.hasValidAndroidSigning(this.$options)) {
                    this.$errors.failWithHelp(constants_1.ANDROID_APP_BUNDLE_SIGNING_ERROR_MESSAGE);
                }
            }
            return canExecuteBase;
        });
    }
}
__decorate([
    decorators_1.cache()
], DebugAndroidCommand.prototype, "debugPlatformCommand", null);
exports.DebugAndroidCommand = DebugAndroidCommand;
$injector.registerCommand("debug|android", DebugAndroidCommand);
