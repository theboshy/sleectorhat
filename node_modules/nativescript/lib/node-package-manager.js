"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const base_package_manager_1 = require("./base-package-manager");
const decorators_1 = require("./common/decorators");
const constants_1 = require("./constants");
class NodePackageManager extends base_package_manager_1.BasePackageManager {
    constructor($childProcess, $errors, $fs, $hostInfo, $logger, $httpClient, $pacoteService) {
        super($childProcess, $fs, $hostInfo, $pacoteService, 'npm');
        this.$errors = $errors;
        this.$logger = $logger;
        this.$httpClient = $httpClient;
    }
    install(packageName, pathToSave, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config.disableNpmInstall) {
                return;
            }
            if (config.ignoreScripts) {
                config["ignore-scripts"] = true;
            }
            const packageJsonPath = path_1.join(pathToSave, "package.json");
            const jsonContentBefore = this.$fs.readJson(packageJsonPath);
            const flags = this.getFlagsString(config, true);
            let params = ["install"];
            const isInstallingAllDependencies = packageName === pathToSave;
            if (!isInstallingAllDependencies) {
                params.push(packageName);
            }
            params = params.concat(flags);
            const cwd = pathToSave;
            const etcDirectoryLocation = path_1.join(cwd, "etc");
            const etcExistsPriorToInstallation = this.$fs.exists(etcDirectoryLocation);
            if (config.path) {
                let relativePathFromCwdToSource = "";
                if (config.frameworkPath) {
                    relativePathFromCwdToSource = path_1.relative(config.frameworkPath, pathToSave);
                    if (this.$fs.exists(relativePathFromCwdToSource)) {
                        packageName = relativePathFromCwdToSource;
                    }
                }
            }
            try {
                const result = yield this.processPackageManagerInstall(packageName, params, { cwd, isInstallingAllDependencies });
                return result;
            }
            catch (err) {
                if (err.message && err.message.indexOf("EPEERINVALID") !== -1) {
                    this.$logger.warn(err.message);
                }
                else {
                    this.$fs.writeJson(packageJsonPath, jsonContentBefore);
                    throw err;
                }
            }
            finally {
                if (!etcExistsPriorToInstallation) {
                    this.$fs.deleteDirectory(etcDirectoryLocation);
                }
            }
        });
    }
    uninstall(packageName, config, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const flags = this.getFlagsString(config, false);
            return this.$childProcess.exec(`npm uninstall ${packageName} ${flags}`, { cwd: path });
        });
    }
    search(filter, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const flags = this.getFlagsString(config, false);
            return this.$childProcess.exec(`npm search ${filter.join(" ")} ${flags}`);
        });
    }
    view(packageName, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrappedConfig = _.extend({}, config, { json: true });
            const flags = this.getFlagsString(wrappedConfig, false);
            let viewResult;
            try {
                viewResult = yield this.$childProcess.exec(`npm view ${packageName} ${flags}`);
            }
            catch (e) {
                this.$errors.fail(e.message);
            }
            return JSON.parse(viewResult);
        });
    }
    searchNpms(keyword) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpRequestResult = yield this.$httpClient.httpRequest(`https://api.npms.io/v2/search?q=keywords:${keyword}`);
            const result = JSON.parse(httpRequestResult.body);
            return result;
        });
    }
    getRegistryPackageData(packageName) {
        return __awaiter(this, void 0, void 0, function* () {
            const registry = yield this.$childProcess.exec(`npm config get registry`);
            const url = registry.trim() + packageName;
            this.$logger.trace(`Trying to get data from npm registry for package ${packageName}, url is: ${url}`);
            const responseData = (yield this.$httpClient.httpRequest(url)).body;
            this.$logger.trace(`Successfully received data from npm registry for package ${packageName}. Response data is: ${responseData}`);
            const jsonData = JSON.parse(responseData);
            this.$logger.trace(`Successfully parsed data from npm registry for package ${packageName}.`);
            return jsonData;
        });
    }
    getCachePath() {
        return __awaiter(this, void 0, void 0, function* () {
            const cachePath = yield this.$childProcess.exec(`npm config get cache`);
            return path_1.join(cachePath.trim(), constants_1.CACACHE_DIRECTORY_NAME);
        });
    }
}
__decorate([
    decorators_1.exported("npm")
], NodePackageManager.prototype, "install", null);
__decorate([
    decorators_1.exported("npm")
], NodePackageManager.prototype, "uninstall", null);
__decorate([
    decorators_1.exported("npm")
], NodePackageManager.prototype, "search", null);
__decorate([
    decorators_1.exported("npm")
], NodePackageManager.prototype, "view", null);
__decorate([
    decorators_1.cache()
], NodePackageManager.prototype, "getCachePath", null);
exports.NodePackageManager = NodePackageManager;
$injector.register("npm", NodePackageManager);
