"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const childProcess = require("./child-process");
const child_process = require("child_process");
const errors = require("./errors");
const _ = require("lodash");
const fs = require("fs");
class Simctl {
    launch(deviceId, appIdentifier, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            let args = [];
            if (options.waitForDebugger) {
                args.push("-w");
            }
            args = args.concat([deviceId, appIdentifier]);
            if (options.args) {
                let applicationArgs = options.args.trim().split(/\s+/);
                _.each(applicationArgs, (arg) => args.push(arg));
            }
            let result = yield this.spawnAsync("launch", args);
            if (options.waitForDebugger) {
                console.log(`${appIdentifier}: ${result}`);
            }
            return result;
        });
    }
    boot(deviceId) {
        return this.spawnAsync("boot", [deviceId]);
    }
    terminate(deviceId, appIdentifier) {
        return this.spawnAsync("terminate", [deviceId, appIdentifier]);
    }
    install(deviceId, applicationPath) {
        return this.spawnAsync("install", [deviceId, applicationPath]);
    }
    uninstall(deviceId, appIdentifier, opts) {
        return this.spawnAsync("uninstall", [deviceId, appIdentifier], opts);
    }
    notifyPost(deviceId, notification) {
        return this.spawnAsync("notify_post", [deviceId, notification]);
    }
    getAppContainer(deviceId, appIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const appContainerPath = yield this.spawnAsync("get_app_container", [deviceId, appIdentifier]);
                // In case application is not installed on simulator, get_app_container returns some random location. After you installation, the application goes in a different location.
                return fs.existsSync(appContainerPath) ? appContainerPath : null;
            }
            catch (e) {
                if (e.message.indexOf("No such file or directory") > -1) {
                    return null;
                }
                throw e;
            }
        });
    }
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            let rawDevices = yield this.spawnAsync("list", ["devices"]);
            // expect to get a listing like
            // -- iOS 8.1 --
            //     iPhone 4s (3CA6E7DD-220E-45E5-B716-1E992B3A429C) (Shutdown)
            //     ...
            // -- iOS 8.2 --
            //     iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
            //     ...
            // so, get the `-- iOS X.X --` line to find the sdk (X.X)
            // and the rest of the listing in order to later find the devices
            let deviceSectionRegex = /-- (iOS) (.+) --(\n    .+)*/mg;
            let match = deviceSectionRegex.exec(rawDevices);
            let matches = [];
            // make an entry for each sdk version
            while (match !== null) {
                matches.push(match);
                match = deviceSectionRegex.exec(rawDevices);
            }
            if (matches.length < 1) {
                errors.fail('Could not find device section. ' + match);
            }
            // get all the devices for each sdk
            let devices = [];
            for (match of matches) {
                let sdk = match[2];
                // split the full match into lines and remove the first
                for (let line of match[0].split('\n').slice(1)) {
                    // a line is something like
                    //    iPhone 4s (A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E) (Shutdown)
                    //    iPad Air 2 (9696A8ED-3020-49FC-90D6-DAFD29A0EA8D) (Shutdown)
                    //    iPad Pro (9.7 inch) (7FF984D4-0755-432D-BE0E-6EB44F0489CB) (Shutdown)
                    //    iPad Pro (12.9 inch) (F02012C8-6D4D-46FF-90D7-5DF90EF579E8) (Booted)
                    // retrieve:
                    //   iPhone 4s
                    //   A99FFFC3-8E19-4DCF-B585-7D9D46B4C16E
                    //   Shutdown
                    let lineRegex = /^\s+(.*?)\s+\(([0-9A-F]{8}(?:-[0-9A-F]{4}){3}-[0-9A-F]{12})\)\s+\((.*?)\)(\s+\((?:.*?)\))?/;
                    let lineMatch = lineRegex.exec(line);
                    if (lineMatch === null) {
                        errors.fail('Could not match line. ' + line);
                    }
                    let available = lineMatch[4];
                    if (available === null || available === undefined) {
                        devices.push({
                            name: lineMatch[1],
                            id: lineMatch[2],
                            fullId: "com.apple.CoreSimulator.SimDeviceType." + lineMatch[1],
                            runtimeVersion: sdk,
                            state: lineMatch[3]
                        });
                    }
                }
            }
            return devices;
        });
    }
    getLog(deviceId, predicate) {
        let predicateArgs = [];
        if (predicate) {
            predicateArgs = ["--predicate", predicate];
        }
        return this.simctlSpawn("spawn", [deviceId, "log", "stream", "--style", "syslog"].concat(predicateArgs));
    }
    spawnAsync(command, args, spawnOpts, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { canExecuteXcrun, xcodeToolsError } = this.verifyXcodeCommandLineToolsAreInstalled();
            if (!canExecuteXcrun) {
                if (opts.skipError) {
                    return null;
                }
                else {
                    throw xcodeToolsError;
                }
            }
            return childProcess.spawn("xcrun", ["simctl", command].concat(args), spawnOpts, opts);
        });
    }
    verifyXcodeCommandLineToolsAreInstalled() {
        let canExecuteXcrun = false;
        let xcodeToolsError = null;
        try {
            const result = childProcess.execSync("xcode-select -p", { stdio: "pipe" });
            canExecuteXcrun = !!(result && result.toString().trim());
            if (!canExecuteXcrun) {
                xcodeToolsError = new Error("Unable to work with iOS Simulator as Xcode Command Line Tools cannot be found.");
            }
        }
        catch (err) {
            xcodeToolsError = err;
        }
        return { canExecuteXcrun, xcodeToolsError };
    }
    simctlSpawn(command, args, spawnOpts) {
        return child_process.spawn("xcrun", ["simctl", command].concat(args), spawnOpts);
    }
}
exports.Simctl = Simctl;
//# sourceMappingURL=simctl.js.map