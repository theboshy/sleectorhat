"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const fs = require("fs");
const os = require("os");
const errors = require("./errors");
const iphone_simulator_xcode_simctl_1 = require("./iphone-simulator-xcode-simctl");
const _ = require("lodash");
class iPhoneSimulator {
    constructor() {
        this.simulator = null;
        this.simulator = this.createSimulator();
    }
    run(applicationPath, applicationIdentifier, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs.existsSync(applicationPath)) {
                errors.fail("Path does not exist ", applicationPath);
            }
            if (options.device) {
                const hasSuchDevice = _.find(yield this.simulator.getDevices(), device => device.name === options.device || device.id === options.device);
                if (!hasSuchDevice) {
                    errors.fail(`Unable to find device ${options.device}.`);
                }
            }
            let sdkVersion = options.sdkVersion || options.sdk;
            if (sdkVersion) {
                let runtimeVersions = _.unique(_.map(yield this.simulator.getDevices(), (device) => device.runtimeVersion));
                if (!_.contains(runtimeVersions, sdkVersion)) {
                    errors.fail(`Unable to find sdk ${sdkVersion}. The valid runtime versions are ${runtimeVersions.join(", ")}`);
                }
            }
            return this.simulator.run(applicationPath, applicationIdentifier, options);
        });
    }
    printDeviceTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            let devices = yield this.simulator.getDevices();
            _.each(devices, device => console.log(`Device Identifier: ${device.fullId}. ${os.EOL}Runtime version: ${device.runtimeVersion} ${os.EOL}`));
        });
    }
    printSDKS() {
        return __awaiter(this, void 0, void 0, function* () {
            let sdks = yield this.simulator.getSdks();
            _.each(sdks, (sdk) => {
                let output = `    Display Name: ${sdk.displayName} ${os.EOL}    Version: ${sdk.version} ${os.EOL}`;
                if (sdk.rootPath) {
                    output += `    Root path: ${sdk.rootPath} ${os.EOL}`;
                }
                console.log(output);
            });
        });
    }
    sendNotification(notification, deviceId) {
        if (!notification) {
            errors.fail("Notification required.");
        }
        return this.simulator.sendNotification(notification, deviceId);
    }
    createSimulator() {
        return new iphone_simulator_xcode_simctl_1.XCodeSimctlSimulator();
    }
}
exports.iPhoneSimulator = iPhoneSimulator;
//# sourceMappingURL=iphone-simulator.js.map